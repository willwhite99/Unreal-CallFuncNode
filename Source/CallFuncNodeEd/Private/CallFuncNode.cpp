#include "CallFuncNode.h"
#include "CallFuncNodeLibrary.h"
#include "KismetCompiler.h"
#include "K2Node_CallFunction.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"

// define our custom pin names
static const FName ObjectPinName = FName(TEXT("Object"));
static const FName NamePinName = FName(TEXT("Name"));
static const FName ResultPinName = FName(TEXT("Result"));

#define LOCTEXT_NAMESPACE "CallFuncNode"
// the offset in pins for the start of the option pins
#define OPTION_PINS_OFFSET 5

static const TCHAR* SlotNames[5] = {
	TEXT("A"),
	TEXT("B"),
	TEXT("C"),
	TEXT("D"),
	TEXT("E")
};

// function names in UCallFuncNodeLibrary, must match!
static const FName FunNames[6] = {
	FName(TEXT("CallNodeFunc_Internal")),
	FName(TEXT("CallNodeFuncOneParam_Internal")),
	FName(TEXT("CallNodeFuncTwoParam_Internal")),
	FName(TEXT("CallNodeFuncThreeParam_Internal")),
	FName(TEXT("CallNodeFuncFourParam_Internal")),
	FName(TEXT("CallNodeFuncFiveParam_Internal")),
};

UK2Node_CallFunc::UK2Node_CallFunc(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
}

void UK2Node_CallFunc::AllocateDefaultPins()
{
	Super::AllocateDefaultPins();

	bReconstructNode = false;

	// input exec pin
	UEdGraphPin* InPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Execute);
	InPin->PinFriendlyName = FText();
	// input object pin
	UEdGraphPin* ObjPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, ObjectPinName);
	ObjPin->PinType.PinSubCategoryObject = UObject::StaticClass();
	// input name pin
	CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Name, NamePinName);
	// output exec pin
	UEdGraphPin* OutPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, UEdGraphSchema_K2::PN_Then);
	OutPin->PinFriendlyName = FText();
	// output result
	UEdGraphPin* OutResult = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Byte, FindObject<UEnum>(ANY_PACKAGE, TEXT("ECallFuncResult"), true), ResultPinName);

	// all parameter pins
	for (int32 i = 0; i < NumOptionPins && i < Entries.Num(); i++)
	{
		UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Wildcard, Entries[i]);

		if (!EntryFriendlyNames.IsValidIndex(i))
			EntryFriendlyNames.Add(FTextStringHelper::CreateFromBuffer(SlotNames[i]));
		Pin->PinFriendlyName = EntryFriendlyNames[i];
	}
}

void UK2Node_CallFunc::PostReconstructNode()
{
	Super::PostReconstructNode();

	bReconstructNode = false;
}

void UK2Node_CallFunc::ReallocatePinsDuringReconstruction(TArray<UEdGraphPin*>& OldPins)
{
	Super::ReallocatePinsDuringReconstruction(OldPins);

	TArray<UEdGraphPin*> OptionPins;
	for (int32 i = OPTION_PINS_OFFSET; i < Pins.Num() && i < OldPins.Num(); i++)
	{
		Pins[i]->PinType = OldPins[i]->PinType;
	}
}

void UK2Node_CallFunc::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	UClass* ActionKey = GetClass();
	// to keep from needlessly instantiating a UBlueprintNodeSpawner, first   
	// check to make sure that the registrar is looking for actions of this type
	// (could be regenerating actions for a specific asset, and therefore the 
	// registrar would only accept actions corresponding to that asset)
	if (ActionRegistrar.IsOpenForRegistration(ActionKey))
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
	}
}

void UK2Node_CallFunc::NotifyPinConnectionListChanged(UEdGraphPin* Pin)
{
	Super::NotifyPinConnectionListChanged(Pin);

	{
		TArray < UEdGraphPin*> PinParams;
		GetOptionsPins(PinParams);

		// See if this pin is one of the wildcard pins
		const bool bIsWildcardPin = (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Wildcard);

		TFunction<bool(UEdGraphPin*)> PinInUse = [&PinInUse](UEdGraphPin* PinToConsider)
		{
			bool bPinInUse = ((PinToConsider->LinkedTo.Num() > 0) || (PinToConsider->ParentPin != nullptr) || !PinToConsider->DoesDefaultValueMatchAutogenerated());
			if (!bPinInUse)
			{
				for (UEdGraphPin* SubPin : PinToConsider->SubPins)
				{
					bPinInUse = PinInUse(SubPin);
					if (bPinInUse)
					{
						break;
					}
				}
			}
			return bPinInUse;
		};

		bool bPinsInUse = PinInUse(Pin);

		bool bPinTypeChanged = false;

		if (bPinsInUse)
		{
			// If the pin was one of the wildcards we have to handle it specially
			if (bIsWildcardPin)
			{
				// If the pin is linked, make sure the other wildcard pins match
				if (Pin->LinkedTo.Num() > 0)
				{
					UEdGraphPin* LinkPin = Pin->LinkedTo[0];

					if (Pin->PinType != LinkPin->PinType)
					{
						Pin->PinType = LinkPin->PinType;
						bPinTypeChanged = true;
					}
				}
			}
		}
		else
		{
			bPinTypeChanged = true;
			Pin->PinType.PinCategory = UEdGraphSchema_K2::PC_Wildcard;
			Pin->PinType.PinSubCategory = NAME_None;
			Pin->PinType.PinSubCategoryObject = nullptr;
		}

		if (bPinTypeChanged)
		{
			const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();

			for (UEdGraphPin* OptionPin : PinParams)
			{
				// Recombine the sub pins back into the OptionPin
				if (OptionPin->ParentPin == nullptr && OptionPin->SubPins.Num() > 0)
				{
					Schema->RecombinePin(OptionPin->SubPins[0]);
				}
			}

			// Get the options again and set them
			GetOptionsPins(PinParams);
			for (UEdGraphPin* OptionPin : PinParams)
			{
				if (!Schema->IsPinDefaultValid(OptionPin, OptionPin->DefaultValue, OptionPin->DefaultObject, OptionPin->DefaultTextValue).IsEmpty())
				{
					Schema->ResetPinToAutogeneratedDefaultValue(OptionPin);
				}
			}

			bReconstructNode = true;
		}
	}
}

void UK2Node_CallFunc::NodeConnectionListChanged()
{
	Super::NodeConnectionListChanged();

	if (bReconstructNode)
	{
		ReconstructNode();
	}
}

void UK2Node_CallFunc::AddInputPin()
{
	Modify();

	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	// Increment the pin count
	if (NumOptionPins < 5)
	{
		Entries.Add(FName(SlotNames[NumOptionPins]));
		EntryFriendlyNames.Add(FTextStringHelper::CreateFromBuffer(SlotNames[NumOptionPins]));

		NumOptionPins++;
		// We will let the AllocateDefaultPins call handle the actual addition via ReconstructNode
		ReconstructNode();
	}
}

void UK2Node_CallFunc::ExpandNode(class FKismetCompilerContext& CompilerContext, UEdGraph* SourceGraph)
{
	Super::ExpandNode(CompilerContext, SourceGraph);

	UFunction* Function = UCallFuncNodeLibrary::StaticClass()->FindFunctionByName(FunNames[NumOptionPins]);
	if (Function == NULL)
	{
		CompilerContext.MessageLog.Error(*LOCTEXT("InvalidFunctionName", "UK2Node_CallFunc: Function not supported or not initialized. @@").ToString(), this);
		return;
	}

	const UEdGraphSchema_K2* Schema = CompilerContext.GetSchema();

	// The call function does all the real work of actually calling our input function
	UK2Node_CallFunction* CallFunction = CompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, SourceGraph);

	CallFunction->SetFromFunction(Function);
	CallFunction->AllocateDefaultPins();
	UEdGraphPin *OutPin = CallFunction->FindPinChecked(UEdGraphSchema_K2::PN_ReturnValue);
	CompilerContext.MessageLog.NotifyIntermediateObjectCreation(CallFunction, this);

	// move all the pins from our node to the call function node (matching the UCallFuncNodeLibrary functions)
	CompilerContext.MovePinLinksToIntermediate(*FindPin(ObjectPinName), *CallFunction->FindPin(TEXT("Object")));
	CompilerContext.MovePinLinksToIntermediate(*FindPin(NamePinName), *CallFunction->FindPin(TEXT("Name")));
	CompilerContext.MovePinLinksToIntermediate(*FindPin(ResultPinName), *OutPin);

	CompilerContext.MovePinLinksToIntermediate(*FindPin(UEdGraphSchema_K2::PN_Execute), *CallFunction->FindPin(UEdGraphSchema_K2::PN_Execute));
	CompilerContext.MovePinLinksToIntermediate(*FindPin(UEdGraphSchema_K2::PN_Then), *CallFunction->FindPin(UEdGraphSchema_K2::PN_Then));

	// move all the parameter pins
	for (int32 i = 0; i < NumOptionPins; i++)
	{
		UEdGraphPin* SrcPin = FindPin(FName(SlotNames[i]));
		UEdGraphPin* FuncPin = CallFunction->FindPin(SlotNames[i]);
		CompilerContext.MovePinLinksToIntermediate(*SrcPin, *FuncPin);
		FuncPin->PinType = SrcPin->PinType;
	}

	BreakAllNodeLinks();
}

void UK2Node_CallFunc::GetOptionsPins(TArray<UEdGraphPin*>& OutPins)
{
	OutPins.Reset();

	for (int32 i = OPTION_PINS_OFFSET; i < Pins.Num(); i++)
	{
		OutPins.Add(Pins[i]);
	}
}

#undef LOCTEXT_NAMESPACE